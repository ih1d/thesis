% Author: Isaac H. Lopez Diaz <isaac.lopez@upr.edu>
% Description: Literature survey

\documentclass{article}

\title{A reflective language for the analysis of graph execution}

\author{Isaac H. Lopez Diaz}

\begin{document}
\maketitle

\section{Introduction}

This paper presents the design of a reflective programming language (PL) that reasons about its
dataflow semantics. A PL is said to be reflective when is able to reason about itself.\cite{smith}
It can be thought of as the process of converting data into a program. The inverse of this process,
reification, can be thought of turning a program into data.\cite{reification} These two processes 
allow a programmer to see the contents of the current execution, much like debugging. However, 
unlike debugging, one can change the semantics of the language on-the-fly.\cite{duplication}

The goal of the language is to better understand dataflow semantics. One such application would be on 
machine learning (ML) programs, since ML programs rely on dataflow graph execution models.\cite{tfmodel} 
This dataflow graphs have their own semantics. This creates a burden on programmers since
they'd be analyzing two programs with their own semantics, the host language like Python and
the ML library like TensorFlow.\cite{omlpl}

Today, ML libraries have been extended permiting programmers to explicitly use dataflow semantics
changing from the usual imperative semantics. However, this conversion from imperative to dataflow
has proven to be challenging for programmers, primarily looking to optimize their code, leading 
to bugs or perfomance issues (the opposite of what the programmer intended to do).\cite{imptograph}
In fact, these extensions are so pervasive that they even alter the execution of state!\cite{tfmodel}

The argument made is that by having a language that can reason about its semantics, in this case,
from procedural to dataflow and vice versa, allow a programmer to understand and see what the
graph is looking like while they are writing their program. Helping them to then use correctly
imperative or graph execution.

The paper is divided in three sections. First, reflective languages are explained and some 
small description of the one to be designed is given. Then, dataflow semantics are explained
in the domain of ML programs. Additionally, the selection of the state of the language is 
justified. Finally, future work to be done is given.

\section{Reflective languages}

Reflective languages started off with the notion of an infinite tower of interpreters.
This means that you'd have an interpreter interpreting an interpreter, and so on. In order for a
language to be reflective, it must have two properties: (1) the ability to reify its own
interpreter, and (2) the ability to reflect on the reified interpreter.\cite{reification} This
gives the ability to extend the language syntax and semantics. 

Evaluating a language usually means consuming expressions and altering the environment,
that is, the bindings of variables.\cite{plai} However, one can also keep track of two
two more things: the continuation and the store. The continuation describes the control 
context, while the store describes the global state of the computation. Previous
implementations have omitted the store \cite{mystery}; for this language the store is
needed, as explained on the next section. 

The language to be designed would be much like a Lisp with the properties mentioned.
The reason for choosing Lisp is because it takes care of syntactic details, that
sometimes are just personal preferences, and in Lisp there is no distinction between
code and data.\cite{sicp} This allows for the ease of development and design of a 
reflective language, and manipulating the store of the language in creative ways.

\section{Graph Execution and ML}

\section{Future Work}

\bibliography{refs}
\bibliographystyle{plain}
\end{document}
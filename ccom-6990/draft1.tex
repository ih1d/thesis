% Author: Isaac H. Lopez Diaz <isaac.lopez@upr.edu>
% Description: Literature survey

\documentclass{article}

\title{A reflective language for the analysis of graph execution}

\author{Isaac H. Lopez Diaz}

\begin{document}
\maketitle

\section{Introduction}

This paper presents the design of a reflective programming language (PL) that reasons about its
dataflow semantics. A PL is said to be reflective when is able to reason about itself.\cite{smith}
It can be thought of as the process of converting data into a program. The inverse of this process,
reification, can be thought of turning a program into data.\cite{reification} These two processes 
allow a programmer to see the contents of the current execution, much like debugging. However, 
unlike debugging, one can change the semantics of the language on-the-fly.\cite{duplication}

The goal of the language is to better understand dataflow semantics. One such application would be on 
machine learning (ML) programs, since they rely on dataflow graph execution models\cite{tfmodel} 
(the terms dataflow and graph execution will be used interchangeably). This dataflow graphs have their 
own semantics. This creates a burden on programmers since they'd be analyzing two programs with their 
own semantics, the host language like Python and the ML library like TensorFlow.\cite{omlpl}

Although, creating a new language may seem unnecessary, given that ML is having success, there is
room for improvement. ML libraries have been extended permiting programmers to explicitly use dataflow 
semantics changing from the usual imperative semantics. However, this conversion from imperative to 
dataflow has proven to be challenging for programmers, primarily looking to optimize their code, leading 
to bugs or perfomance issues (the opposite of what the programmer intended to do).\cite{imptograph}
In fact, these extensions are so pervasive that they even alter the execution and modification of 
state!\cite{tfmodel} Two surveys (\cite{impact}, \cite{imptograph}) give a taxonomy of bugs which in some 
way correlates to programming languages. The cause of bugs can range from lack of features in a language 
(e.g. lack of type system guarantees) to a misunderstanding of the  change of semantics from imperative to 
graph execution.

The paper is divided in three sections. First, reflective languages are explained and some 
small description of the one to be designed is given. Then, dataflow semantics are explained
in the domain of ML programs. Additionally, the selection of the state of the language is 
justified. Finally, the design of the language is presented.

\section{Reflective languages}

Reflective languages started off with the notion of an infinite tower of interpreters.
This means that you'd have an interpreter interpreting an interpreter, and so on. In order for a
language to be reflective, it must have two properties: (1) the ability to reify its own
interpreter, and (2) the ability to reflect on the reified interpreter.\cite{reification} This
gives the ability to extend the language syntax and semantics. 

Evaluating a language usually means consuming expressions and altering the environment,
that is, the bindings of variables.\cite{plai} However, one can also keep track of two
two more things: the continuation and the store. The continuation describes the control 
context, while the store describes the global state of the computation. Previous
implementations have omitted the store \cite{mystery}; for this language the store is
needed, as explained on the next section. 

The language to be designed would be much like a Lisp with the properties mentioned.
The reason for choosing Lisp is because it takes care of syntactic details, that
sometimes are just personal preferences, and in Lisp there is no distinction between
code and data.\cite{sicp} This allows for the ease of development and design of a 
reflective language, and manipulating the store of the language in creative ways.

\section{Dataflow Semantics, Bugs and ML}

\section{The Design of the Language}
The basis of our evaluator is the metacircular interpreter by 
\bibliography{refs}
\bibliographystyle{plain}
\end{document}